"""
Actuator Module

This module defines the base class for all control actuators used in the 
satellite simulation, providing core functionality for axis definition, 
data logging, parameter loading, and torque application.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.artist import Artist
from abc import abstractmethod
from typing import Optional, Union, Iterable, List
import yaml
from collections import defaultdict, deque
# Assuming BaseAnimation is imported from a relevant module
from animation import BaseAnimation


class Actuator:
    """
    Base class for a control actuator (e.g., magnetorquers, reaction wheels).

    All specialized actuator classes inherit from :class:`Actuator` and must 
    implement the torque application logic.

    Attributes
    ----------
    axis : :class:`numpy.ndarray`
        The nominal direction vector of the actuator's output (e.g., the dipole 
        moment direction or wheel axis) in the **body frame**, shape (3,).
    history_size : int
        The maximum number of time steps to store in the internal data history.
    _params : list of str
        A list of attribute names that will be displayed on the dashboard in the
        simulation frame. What attributes in data to monitor during operation.
    name : str
        A descriptive name for the actuator type.
    param : dict
        A dictionary storing parameters loaded from an external source (e.g., YAML file).
    data : :class:`collections.defaultdict` of :class:`collections.deque`
        A container for logging historical data (e.g., commanded torque, time). 
        The deques have a maximum length set by :attr:`history_size`.
    """
    history_size: int = 100
    _params: List[str] = []
    name: str = "Ideal Actuator"

    def __init__(self, axis: Optional[np.ndarray]=None) -> None:
        """
        Initializes the Actuator with an optional axis and sets up logging.

        The provided axis vector is automatically normalized.

        Parameters
        ----------
        axis : :class:`numpy.ndarray`, optional
            The direction of the actuator's output in the body frame, shape (3,).
            If None, defaults to $\mathbf{x} = [1.0, 0.0, 0.0]$.
        """
        # Normalize the axis
        self.axis = np.array([1.0, 0.0, 0.0]) if axis is None else axis / np.linalg.norm(axis)
        self.param = {}
        self.data = defaultdict(lambda: deque(maxlen=self.history_size))
        self.log_data("time", 0.0)

    def log_data(self, key: str, value: Optional[Union[float, np.ndarray]]):
        """
        Logs a data point for a specified key to the historical data deque.

        Parameters
        ----------
        key : str
            The identifier for the data series (e.g., "time", "torque_out").
        value : float or :class:`numpy.ndarray`, optional
            The data value to record.
        """
        self.data[key].append(value)

    def load_from_yaml(self, filepath: str):
        """
        Loads actuator parameters from a YAML file.

        The loaded parameters are stored in :attr:`param`.

        Parameters
        ----------
        filepath : str
            The path to the YAML configuration file.
        """
        with open(filepath, 'r') as file:
            self.param = yaml.safe_load(file)
        file.close()

    @abstractmethod
    def apply_torque(self, tau: float, dt: float=0.1, **kwargs) -> float:
        """
        Calculates and returns the torque generated by the actuator. Torque
        is a bit of a misnomer as the actuation does not have to be torque. 
        For reaction wheels it will be, but for magnetorquers it'll be 
        magnetic dipole.

        This is an abstract method that must be implemented by subclasses to 
        model the specific physical characteristics of the actuator (e.g., 
        saturation limits, efficiency, noise).

        Parameters
        ----------
        tau : float
            The reference or commanded magnitude of the torque.
        dt : float, optional
            The time step duration in seconds. Defaults to 0.1 s.
        **kwargs : dict
            Additional parameters required for specific actuator models (e.g., 
            magnetic field vector for magnetorquers).

        Returns
        -------
        float
            The scalar magnitude of the torque applied by the actuator along 
            its axis.
        """
        return tau

    @staticmethod
    def saturate(value: float,
                 maximum: Optional[float]=None,
                 minimum: Optional[float]=None) -> float:
        """
        Limits a given value to be within a specified range [minimum, maximum].

        If maximum or minimum are not provided, they default to $\pm \infty$.

        Parameters
        ----------
        value : float
            The value to be saturated.
        maximum : float, optional
            The upper limit. If None, no upper limit is applied.
        minimum : float, optional
            The lower limit. If None, no lower limit is applied.

        Returns
        -------
        float
            The saturated value.
        """
        maximum = maximum if maximum is not None else np.inf
        minimum = minimum if minimum is not None else -np.inf

        return min(maximum, max(value, minimum))

    def __str__(self) -> str:
        """
        Provides a string representation of the actuator's key parameters.

        This uses the parameter names defined in :attr:`_params`.

        Returns
        -------
        str
            A formatted string showing the names and values of selected parameters.
        """
        s = ''
        for key in self._params:
            s += "{:>12}: {}\n".format(key, getattr(self, key))
        return s

# WARN: The plotting has been abandoned for now as it was infuriatingly buggy
##################### Plotting animation part of the actuators ####################
# OBS: Plotting parameters for each key
PLOTTING_PARAMETES = {
    "torque": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": r"$\tau$ (Nm)",
        "y_lim": (-1.0e-3, 1.0e-3),
        "grid": True,
        "legend": False
    },
    "reference": {
        # "title": "Reaction Wheel",
        "linestyle": "--",
        "x_label": "Time (s)",
        "y_label": r"$\tau_{ref}$ (Nm)",
        "y_lim": (-1.0e-3, 1.0e-3),
        "grid": True,
        "legend": False
    },
    "drag": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": r"$\tau_{d}$ (Nm)",
        "y_lim": (-1.0e-3, 1.0e-3),
        "grid": True,
        "legend": False
    },
    "motor": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": r"$\tau_{m}$ (Nm)",
        "y_lim": (-1.0e-3, 1.0e-3),
        "grid": True,
        "legend": False
    },
    "w": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": r"$\omega$ ($\frac{rad}{s}$)",
        "y_lim": (-1.0, 1.0),
        "grid": True,
        "legend": False
    },
    "w_dot": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": r"$\omega$ ($\frac{rad}{s}$)",
        "y_lim": (0, 1.0),
        "grid": True,
        "legend": False
    },
    "rpm": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": r"$\omega$ (rpm)",
        "y_lim": (-3000, 3000),
        "grid": True,
        "legend": False
    },
    "I": {
        # "title": "Reaction Wheel",
        "linestyle": "-",
        "x_label": "Time (s)",
        "y_label": "Current (A)",
        "y_lim": (0, 1),
        "grid": True,
        "legend": False
    },
}


class ActuatorAnimation(BaseAnimation):
    def __init__(self, actuator) -> None:
        self.actuator = actuator

        self.fig = plt.figure() # WARN: This needs to happen before calling super()__init__() for BaseAnimation
        self.ax = self.fig.add_subplot()
        self.color = "blue"
        self.key = "torque"
        # self.key = "w"
        # self.key = "rpm"

        super().__init__()
        # self.animation.blit = False

    def add_canvas(self, canvas):
        self.canvas = canvas

    def draw(self):
        return super().draw()

    def update_display_values(self):
        for key, var in self.display_vars.items():
            value = self.actuator.data[key][-1]
            # txt = "{:<12.3e}".format(value)
            txt = "{:<12.5f}".format(value)
            var.set(txt)

    def swap_data(self, key: str):
        print(key)
        self.key = key
        self.fig.clear()
        self.init_anim()
        # param = PLOTTING_PARAMETES[self.key]
        # # self.ax.clear()
        # # self.init_anim()
        # self.ax.set_ylabel(param["y_label"])
        # self.ax.set_ylim(param["y_lim"])
        # self.ax.grid(param["grid"])
        # if param["legend"]:
        #     self.ax.legend()
        self.fig.canvas.draw_idle()
        # self.canvas.draw_idle()

    def init_anim(self) -> Iterable[Artist]:
        param = PLOTTING_PARAMETES[self.key]
        # self.ax.set_xlabel(param["x_label"])
        self.ax.set_ylabel(param["y_label"])
        self.ax.set_ylim(param["y_lim"])
        self.ax.set_xlim(self.time.t0, self.time.t_end)
        self.ax.grid(param["grid"])
        if param["legend"]:
            self.ax.legend()

        self.line, = self.ax.plot(
            [], [],
            self.color,
            linestyle=param["linestyle"],
            label=param["y_label"],
            linewidth=2
        )
        # Only torque has a reference at this time
        if self.key == "torque":
            self.ref_line, = self.ax.plot(
                [], [], 
                color=self.color,
                linewidth=2,
                linestyle=PLOTTING_PARAMETES["reference"]["linestyle"],
                label=PLOTTING_PARAMETES["reference"]["y_label"]
            )
            return (self.line, self.ref_line, )
        return (self.line, )

    def update_anim(self, frame: int) -> Iterable[Artist]:
        x = self.actuator.data["time"]
        y = self.actuator.data[self.key]

        self.update_display_values()

        self.line.set_data(x, y)
        if len(x) > ((self.time.t_end - self.time.t0) // (self.time.t_end + 1)):
            self.ax.set_xlim(x[0], x[-1] + 3.0)

        if self.key == "torque":
            y_ref = self.actuator.data["reference"]
            self.ref_line.set_data(x, y_ref)
            return (self.line, self.ref_line, )

        return (self.line, )


if __name__ == "__main__":
    pass


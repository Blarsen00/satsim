import numpy as np
import yaml
import misc
import quaternion
from Satellite import Satellite
from Reference import Reference
from Actuators.Reactionwheel import ReactionWheel

class Controller:
    def __init__(self):
        pass

    def output(self, sat:Satellite, ref:Reference):
        pass

class ControllerLegacy:
    def __init__(self, filename="Yaml/Controller.yaml"):
        with open(filename, 'r') as file:
            self.param = yaml.safe_load(file)
        file.close()

        try:
            self.controller = self.param["controller"]
        except:
            print("Could not find controller type. Setting it to PD controller")
            self.controller = "pd"

        print("#################### Controller parameters ####################")
        print(f"The chosen controller is: {self.controller}")
        for key in self.param:
            if key == "controller":
                continue
            print(f"- {key}: {self.param[key]}")
        print("##############################################################")
        print()

    def output(self, satellite: Satellite, reference: Reference):
        if self.controller == "pd":
            return self.pd(satellite, reference)
        if self.controller == "smc":
            return self.smc(satellite, reference)
        print(f"Did not recognise controller {self.controller}")

    def pd(self, satellite: Satellite, reference: Reference):
        try:
            alpha = self.param["alpha"]
        except:
            alpha = 1
        try:
            beta = self.param["beta"]
        except:
            beta = 1
        try:
            p = [alpha * x for x in self.param["p"]]
            d = [beta * x for x in self.param["d"]]
        except:
            print("Could not load the parameters for the PD controller")
            return

        # (7.3)
        # Quaternion in books: [q1-3, q4]
        qe = misc.quat_conjugate(satellite.q) * reference.qc
        qe = reference.qc * misc.quat_conjugate(satellite.q)
        qvec = quaternion.as_float_array(qe)[1:]
        we = satellite.w - reference.wc

        # The sign is problematic for some reason
        # L =  -np.sign(qe.w) * np.multiply(p, qvec) - np.multiply(d, satellite.w)
        L =  -np.multiply(p, qvec) - np.multiply(d, we)
        return L


    def smc(self, satellite: Satellite, reference: Reference):
        J = satellite.J
        try:
            G = self.param["G"]
            k = self.param["k"]
            e = self.param["e"]
        except:
            print("Could not load the parameters needed for the smc controller")
            return

        # Error quaternion
        # qe = misc.quat_conjugate(satellite.q) * reference.qc
        qe = reference.qc * misc.quat_conjugate(satellite.q)
        q_13 = quaternion.as_float_array(qe)[1:]
        q4 = qe.w

        # Sliding mode manifold (7.23a)
        s_manifold = (satellite.w - reference.wc) + k * q_13
        s_bar = misc.saturation(s_manifold, e)

        # Moment generated from sliding mode controller (7.23b)
        L = J @ (k / 2 * (abs(q4) * (reference.wc - satellite.w) - \
                        misc.skew_symmetric(q_13) @ (reference.wc - satellite.w).T) \
                        + reference.wc_dot - G @ s_bar.T) \
                        + misc.skew_symmetric(satellite.w) @ J @ satellite.w.T

        return L.ravel()


def sliding_mode_controller(q, qc, w, wc, wc_dot, J, G, epsilon, k):
    """
    Sliding mode controller that reorients the spacecraft to the reference attitude in the shortest distance.
    Returns:
    L : numpy array
        The control torque generated by the sliding mode controller.
    """
    # Error quaternion
    qe = misc.quat_conjugate(q) * qc
    q_13 = quaternion.as_float_array(qe)[1:]
    q4 = qe.w

    # q4 = quaternion.as_float_array(q).T @ quaternion.as_float_array(qc)
    # q_13 = misc.quaternion_matrix(qc).T @ quaternion.as_float_array(q) 

    # Sliding mode manifold (7.23a)
    # s_manifold = (w - wc) + k * np.sign(q4) * q_13
    s_manifold = (w - wc) + k * q_13
    s_bar = misc.saturation(s_manifold, epsilon)

    # # Moment generated from sliding mode controller (7.23b)
    # L = J @ (k / 2 * (abs(q4) * (wc - w) - \
    #                 np.sign(q4) * misc.skew_symmetric(q_13) @ (wc - w).T) \
    #                 + wc_dot - G @ s_bar.T) \
    #                 + misc.skew_symmetric(w) @ J @ w.T

    # Moment generated from sliding mode controller (7.23b)
    L = J @ (k / 2 * (abs(q4) * (wc - w) - \
                    misc.skew_symmetric(q_13) @ (wc - w).T) \
                    + wc_dot - G @ s_bar.T) \
                    + misc.skew_symmetric(w) @ J @ w.T


    return L.ravel()  


def PDcontroller(q_ref, q, w, p=[1.0, 1.0, 1.0], d=[1.0, 1.0, 1.0]):
    """
    PD regulator for the regulation case
    """
    # (7.3)
    # Quaternion in books: [q1-3, q4]

    # qe = q_ref * misc.quat_conjugate(q)
    # qvec = quaternion.as_float_array(qe)[1:]
    # q4 = quaternion.as_float_array(qe)[0]

    qe = misc.quat_conjugate(q) * q_ref  
    qvec = quaternion.as_float_array(qe)[1:]

    # q4 = quaternion.as_float_array(qe)[0]
    # if abs(q4) < 0.1:
    #     q4 = 1
    # L =  -np.multiply(p, qvec) * np.sign(q4) - np.multiply(d, w)

    L =  -np.multiply(p, qvec) - np.multiply(d, w)
    return L

def PIDcontroller(q_ref, q, w, 
                  dt=0.1,
                  integral_sum=[0.0, 0.0, 0.0],
                  p=[3.0, 1.0, 3.0], 
                  i=[1.0, 1.0, 1.0], 
                  d=[1.0, 1.0, 1.0]):
    """
    PID regulator for the regulation case
    """
    qvec = misc.quaternion_matrix(q_ref).T @ quaternion.as_float_array(q) 
    q4 = quaternion.as_float_array(q).T @ quaternion.as_float_array(q_ref)
    control = -np.multiply(p, qvec) * np.sign(q4) \
                - np.multiply(i, integral_sum) \
                - np.multiply(d, w) 
    return control, integral_sum + np.quaternion(q4, *qvec) * dt


class PDController(Controller):
    def __init__(self, filename="Yaml/Controller.yaml") -> None:
        super().__init__()
        with open(filename, 'r') as file:
            self.param = yaml.safe_load(file)
        file.close()

        try: 
            self.p = self.param["p"]
            self.d = self.param["d"]
        except:
            print("Could not read the pd controller parameters")

        print("#################### PD Controller parameters ####################")
        for key in self.param.keys():
            print(f"{key}: {self.param[key]}")
        print("##############################################################")

    def torque(self, q, w, qc, wc):
        qe = qc * misc.quat_conjugate(q)
        qvec = quaternion.as_float_array(qe)[1:]
        we = w - wc

        # The sign is problematic for some reason
        # L =  -np.sign(qe.w) * np.multiply(self.p, qvec) - np.multiply(self.d, we)
        L =  -np.multiply(self.p, qvec) - np.multiply(self.d, we)
        return L

    def output(self, sat:Satellite, ref:Reference):
        return self.torque(sat.q, sat.w, ref.qc, ref.wc)

def test_torque(q, w, qc, wc):
    qe = qc * misc.quat_conjugate(q)
    qvec = quaternion.as_float_array(qe)[1:]
    we = np.subtract(w, wc)

    # The sign is problematic for some reason
    # L =  -np.sign(qe.w) * np.multiply(self.p, qvec) - np.multiply(self.d, we)
    L =  -np.multiply([1.0, 1.0, 1.0], qvec) - np.multiply([1.0, 1.0, 1.0], we)
    return L


if __name__ == "__main__":
    # controller = PDController()
    q = np.quaternion(1.0, 2.0, 3.0, 4.0)
    qc = np.quaternion(1.0, 0.0, 0.0, 0.0)
    # qc = np.quaternion(0.182574185835055, 0.365148371670111, 0.547722557505166, 0.730296743340221)
    w = [1.0, 2.0, 3.0]
    wc = [1.0, 0.0, 0.0]
    print(test_torque(q, w, qc, wc))
    print(q * qc)


